#!/usr/bin/env bash
# Purpose: Generate test fixtures, factories, and mocks
# Why: Provides reusable test data for all test types
# How: Analyzes data models and architecture to generate fixtures

set -euo pipefail

# Source common utilities
SCRIPT_DIR="$(CDPATH="" cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/qa-common.sh"

# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
# Parse arguments
# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

export DRY_RUN=false

while [[ $# -gt 0 ]]; do
    case $1 in
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        --help)
            echo "Usage: generate-fixtures.sh [OPTIONS]"
            echo ""
            echo "Generate test fixtures, factories, and mocks"
            echo ""
            echo "Options:"
            echo "  --dry-run    Preview changes without modifying files"
            echo "  --help       Show this help message"
            exit 0
            ;;
        *)
            echo "Unknown option: $1"
            echo "Use --help for usage information"
            exit 1
            ;;
    esac
done

echo "ðŸ­ Generating test fixtures and mocks..."
if is_dry_run; then
    echo "   [DRY-RUN MODE - No files will be modified]"
fi
echo ""

# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
# Create backup before making changes
# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

if ! is_dry_run; then
    BACKUP_DIR=$(create_backup "generate-fixtures")
    print_info "Backup created: $BACKUP_DIR"
    echo ""
fi

# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
# Step 1: Check and generate architecture
# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

check_and_generate_architecture

# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
# Step 2: Load architecture and feature context
# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

load_architecture_context
load_integration_landscape
load_feature_context

LANGUAGE="${ARCH_LANGUAGE:-$(detect_language)}"
FRAMEWORK="${ARCH_FRAMEWORK:-unknown}"

print_section "ðŸ“Š Context Loaded"
echo "Language:        $LANGUAGE"
echo "Framework:       $FRAMEWORK"
echo "Test Framework:  ${ARCH_TEST_FRAMEWORK:-auto-detect}"

if [ -n "${FEATURE_ENTITIES:-}" ]; then
    echo ""
    echo "Entities found:"
    echo "$FEATURE_ENTITIES" | while read -r entity; do
        echo "  â€¢ $entity"
    done
fi

if [ -n "${ARCH_EXTERNAL_SERVICES:-}" ]; then
    echo ""
    echo "External services found:"
    echo "$ARCH_EXTERNAL_SERVICES" | while read -r service; do
        echo "  â€¢ $service"
    done
fi

# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
# Step 3: Generate fixtures based on language
# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

generate_python_fixtures() {
    print_section "ðŸ Generating Python Fixtures"
    
    mkdir -p tests/fixtures
    
    # Generate conftest.py if it doesn't exist
    if [ ! -f "tests/fixtures/conftest.py" ]; then
        cat > tests/fixtures/conftest.py << 'EOF'
"""
Test fixtures for pytest

This module provides reusable fixtures for all tests.
Generated by /gbm.qa.generate-fixtures
"""

import pytest
from typing import Generator

# Add your fixtures here
EOF
        print_success "Created tests/fixtures/conftest.py"
    fi
    
    # Generate entity fixtures
    if [ -n "${FEATURE_ENTITIES:-}" ]; then
        cat > tests/fixtures/entity_fixtures.py << 'EOF'
"""
Entity fixtures

Provides fixtures for domain entities.
"""

import pytest
from faker import Faker

fake = Faker()

EOF
        
        echo "$FEATURE_ENTITIES" | while read -r entity; do
            if [ -n "$entity" ]; then
                local entity_lower=$(echo "$entity" | tr '[:upper:]' '[:lower:]')
                cat >> tests/fixtures/entity_fixtures.py << EOF

@pytest.fixture
def ${entity_lower}_data():
    """Sample ${entity} data"""
    return {
        "id": fake.random_int(min=1, max=1000),
        "name": fake.name(),
        "created_at": fake.date_time(),
    }


@pytest.fixture
def ${entity_lower}(${entity_lower}_data):
    """${entity} instance"""
    # TODO: Replace with actual ${entity} model
    return ${entity_lower}_data
EOF
            fi
        done
        
        print_success "Created tests/fixtures/entity_fixtures.py"
    fi
    
    # Generate mock services
    if [ -n "${ARCH_EXTERNAL_SERVICES:-}" ]; then
        cat > tests/fixtures/mock_services.py << 'EOF'
"""
Mock external services

Provides mocks for external service integrations.
"""

import pytest
from unittest.mock import Mock, MagicMock

EOF
        
        echo "$ARCH_EXTERNAL_SERVICES" | while read -r service; do
            if [ -n "$service" ]; then
                service_lower=$(echo "$service" | tr '[:upper:]' '[:lower:]' | tr ' ' '_')
                cat >> tests/fixtures/mock_services.py << EOF

@pytest.fixture
def mock_${service_lower}():
    """Mock ${service} service"""
    mock = Mock()
    mock.call.return_value = {"status": "success"}
    mock.get.return_value = {"data": "sample"}
    return mock
EOF
            fi
        done
        
        print_success "Created tests/fixtures/mock_services.py"
    fi
}

generate_javascript_fixtures() {
    print_section "ðŸ“¦ Generating JavaScript Fixtures"
    
    mkdir -p tests/fixtures
    
    # Generate fixtures index
    cat > tests/fixtures/index.js << 'EOF'
/**
 * Test fixtures for Jest/Vitest
 * 
 * Provides reusable test data and mocks.
 * Generated by /gbm.qa.generate-fixtures
 */

const { faker } = require('@faker-js/faker');

EOF
    
    # Generate entity fixtures
    if [ -n "${FEATURE_ENTITIES:-}" ]; then
        echo "$FEATURE_ENTITIES" | while read -r entity; do
            if [ -n "$entity" ]; then
                entity_lower=$(echo "$entity" | tr '[:upper:]' '[:lower:]')
                cat >> tests/fixtures/index.js << EOF

/**
 * Generate ${entity} test data
 */
function create${entity}Data() {
  return {
    id: faker.number.int({ min: 1, max: 1000 }),
    name: faker.person.fullName(),
    createdAt: faker.date.recent(),
  };
}

module.exports.create${entity}Data = create${entity}Data;
EOF
            fi
        done
    fi
    
    print_success "Created tests/fixtures/index.js"
}

generate_php_fixtures() {
    print_section "ðŸ˜ Generating PHP Fixtures"
    
    mkdir -p tests/Fixtures
    
    # Generate base fixture class
    cat > tests/Fixtures/BaseFixture.php << 'EOF'
<?php

namespace Tests\Fixtures;

use Faker\Factory;
use Faker\Generator;

/**
 * Base fixture class
 * 
 * Provides common fixture functionality.
 * Generated by /gbm.qa.generate-fixtures
 */
abstract class BaseFixture
{
    protected Generator $faker;

    public function __construct()
    {
        $this->faker = Factory::create();
    }
}
EOF
    
    print_success "Created tests/Fixtures/BaseFixture.php"
}

generate_java_fixtures() {
    print_section "â˜• Generating Java Fixtures"
    
    mkdir -p src/test/java/fixtures
    
    # Generate fixture builder
    cat > src/test/java/fixtures/TestDataBuilder.java << 'EOF'
package fixtures;

import com.github.javafaker.Faker;

/**
 * Test data builder
 * 
 * Provides test data generation utilities.
 * Generated by /gbm.qa.generate-fixtures
 */
public class TestDataBuilder {
    private static final Faker faker = new Faker();
    
    public static Faker getFaker() {
        return faker;
    }
}
EOF
    
    print_success "Created src/test/java/fixtures/TestDataBuilder.java"
}

# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
# Step 4: Generate fixtures based on detected language
# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

case "$LANGUAGE" in
    python|Python)
        generate_python_fixtures
        ;;
    javascript|JavaScript|typescript|TypeScript)
        generate_javascript_fixtures
        ;;
    php|PHP)
        generate_php_fixtures
        ;;
    java|Java)
        generate_java_fixtures
        ;;
    *)
        print_warning "Language '$LANGUAGE' not fully supported yet"
        print_info "Creating basic fixture structure..."
        mkdir -p tests/fixtures
        ;;
esac

# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
# Step 5: Generate report
# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

mkdir -p .gobuildme/specs/qa-test-scaffolding

cat > .gobuildme/specs/qa-test-scaffolding/fixtures-report.md << EOF
# Test Fixtures Generation Report

**Generated**: $(date)
**Language**: $LANGUAGE
**Framework**: $FRAMEWORK

## Fixtures Created

EOF

if [ -n "${FEATURE_ENTITIES:-}" ]; then
    cat >> .gobuildme/specs/qa-test-scaffolding/fixtures-report.md << EOF
### Entity Fixtures

$(echo "$FEATURE_ENTITIES" | while read -r entity; do echo "- $entity"; done)

EOF
fi

if [ -n "${ARCH_EXTERNAL_SERVICES:-}" ]; then
    cat >> .gobuildme/specs/qa-test-scaffolding/fixtures-report.md << EOF
### Mock Services

$(echo "$ARCH_EXTERNAL_SERVICES" | while read -r service; do echo "- $service"; done)

EOF
fi

cat >> .gobuildme/specs/qa-test-scaffolding/fixtures-report.md << 'EOF'
## Next Steps

1. Review generated fixtures
2. Customize fixture data for your domain
3. Add relationships between entities
4. Use fixtures in your tests:
   - Import fixtures in test files
   - Use as function parameters
   - Customize as needed

## Usage Examples

### Python (pytest)
```python
def test_example(user, mock_stripe):
    # user and mock_stripe are auto-injected
    assert user.name is not None
```

### JavaScript (Jest)
```javascript
const { createUserData } = require('./fixtures');

test('example', () => {
  const user = createUserData();
  expect(user.name).toBeDefined();
});
```

EOF

print_section "âœ… Fixture Generation Complete"
echo "ðŸ“„ Report saved to: .gobuildme/specs/qa-test-scaffolding/fixtures-report.md"
echo ""
echo "Next steps:"
echo "  1. Review generated fixtures in tests/fixtures/"
echo "  2. Customize fixture data for your domain"
echo "  3. Use fixtures in your tests"
echo "  4. Run: /gbm.qa.implement-tests"
echo ""

